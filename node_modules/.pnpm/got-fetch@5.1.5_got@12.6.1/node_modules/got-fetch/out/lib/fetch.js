var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
import { URL, URLSearchParams } from 'url';
import { format } from 'util';
import { GotFetchResponse } from './response.js';
import { finished, Readable } from "node:stream";
import { once } from "node:events";
const getMethodsWithBody = new Set(["GET", "HEAD"]);
export function createFetch(got) {
    const globalCache = new Map();
    return (input, opts) => __awaiter(this, void 0, void 0, function* () {
        var _a, _b;
        const url = new URL(typeof input === 'string' ? input : input.url);
        const request = typeof input === 'object' ? input : opts || {};
        if (request.mode === 'no-cors' || request.mode === 'same-origin' || request.mode === 'navigate') {
            throw new TypeError(format('request.mode not supported: %s', request.mode));
        }
        if (request.cache === 'only-if-cached') {
            throw new TypeError(format('request.cache not supported: %s', request.cache));
        }
        if (request.redirect === 'error' || request.redirect === 'manual') {
            throw new TypeError(format('request.redirect not supported: %s', request.redirect));
        }
        // naive check to make sure headers are a plain object
        if (request.headers && typeof request.headers !== 'object') {
            throw new TypeError(format('request.headers must be plain object: %j', request.headers));
        }
        // got does not merge base searchParams with the url's searchParams
        // but it does merge searchParams options
        // so we clone the url's searchParams
        // we also clear the url's search to work around this bug
        // https://github.com/sindresorhus/got/issues/1188
        const searchParams = new URLSearchParams(url.searchParams);
        url.search = '';
        const { body = "", headers: bodyHeaders } = serializeBody(request.body);
        const method = (_a = request.method) !== null && _a !== void 0 ? _a : "GET";
        const gotOpts = {
            // url needs to be stringified to support UNIX domain sockets, and
            // For more info see https://github.com/alexghr/got-fetch/pull/8
            url: url.toString(),
            searchParams,
            followRedirect: true,
            throwHttpErrors: false,
            method,
            resolveBodyOnly: false,
            // we'll do our own response parsing in `GotFetchResponse`
            responseType: undefined,
            allowGetBody: getMethodsWithBody.has(method.toUpperCase()) && Boolean(body),
            headers: Object.assign(Object.assign({}, normaliseHeaders(bodyHeaders !== null && bodyHeaders !== void 0 ? bodyHeaders : {})), normaliseHeaders((_b = request.headers) !== null && _b !== void 0 ? _b : {}))
        };
        // there's a bug in got where it crashes if we send both a body and cache
        // https://github.com/sindresorhus/got/issues/1021
        if ((typeof request.cache === 'undefined' || request.cache === 'default') && !gotOpts.body) {
            gotOpts.cache = globalCache;
        }
        const gotReq = got(Object.assign(Object.assign({}, gotOpts), { isStream: true }));
        if (request.signal) {
            const abortHandler = () => gotReq.destroy();
            request.signal.addEventListener('abort', abortHandler);
            const cleanup = finished(gotReq, () => {
                request.signal.removeEventListener('abort', abortHandler);
                cleanup();
            });
        }
        try {
            // got creates a Duplex stream of the request but it only allows writing
            // to it sometimes. It's list of methods which accept a payload is
            // incomplete so alwasy try to close the request and swallow any errors
            if (body instanceof Readable) {
                body.pipe(gotReq);
            }
            else {
                gotReq.end(body);
            }
        }
        catch (_c) {
            // noop
            // I hate this
        }
        const raceController = new AbortController();
        // wait for the first chunk to arrive so that got gives us back the status
        // one of two things could happen: either we get back a body with a
        // length > 0, in which case at least one 'data' event is emitted; OR
        // we get an empty body (lenght === 0) in which case got will emit 'end'
        const [firstChunk] = yield Promise.race([
            once(gotReq, "data", { signal: raceController.signal }),
            once(gotReq, "end", { signal: raceController.signal }),
        ]);
        // cancel whoever lost
        raceController.abort();
        const response = gotReq.response;
        // put back the chunk we got (if any) or create an empty ReadableStream
        const responseBody = Readable.from(firstChunk ? restream(firstChunk, gotReq) : []);
        return new GotFetchResponse(responseBody, {
            headers: response.headers,
            redirected: response.redirectUrls && response.redirectUrls.length > 0,
            status: response.statusCode,
            statusText: response.statusMessage,
            type: "default",
            // according to spec this should be the final URL, after all redirects
            url: response.redirectUrls.length > 0
                // using Array.prototype.at would've been nice but it's not
                // supported by anything below Node 16.8
                ? response.redirectUrls[response.redirectUrls.length - 1].href
                : url.href,
        });
    });
}
function restream(firstChunk, req) {
    return __asyncGenerator(this, arguments, function* restream_1() {
        var _a, e_1, _b, _c;
        yield yield __await(firstChunk);
        try {
            for (var _d = true, req_1 = __asyncValues(req), req_1_1; req_1_1 = yield __await(req_1.next()), _a = req_1_1.done, !_a;) {
                _c = req_1_1.value;
                _d = false;
                try {
                    const chunk = _c;
                    yield yield __await(chunk);
                }
                finally {
                    _d = true;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (!_d && !_a && (_b = req_1.return)) yield __await(_b.call(req_1));
            }
            finally { if (e_1) throw e_1.error; }
        }
    });
}
function normaliseHeaders(headers) {
    const out = {};
    if (Array.isArray(headers)) {
        headers.forEach(([header, value]) => {
            out[header.toLowerCase()] = value;
        });
    }
    else if (typeof (headers === null || headers === void 0 ? void 0 : headers.forEach) === "function") {
        headers.forEach((value, header) => {
            out[header.toLowerCase()] = value;
        });
    }
    else {
        Object.keys(headers).forEach((header) => {
            out[header.toLowerCase()] = headers[header];
        });
    }
    return out;
}
function serializeBody(body) {
    if (!body) {
        return {};
    }
    else if (body instanceof URLSearchParams) {
        const serialized = body.toString();
        return {
            body: serialized,
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded; charset=utf-8',
                'Content-Length': String(Buffer.byteLength(serialized, 'utf8'))
            }
        };
    }
    else if (typeof body === 'string') {
        return {
            body,
            headers: {
                'Content-Type': 'text/plain; charset=utf-8',
                'Content-Length': String(Buffer.byteLength(body, 'utf8')),
            }
        };
    }
    else if (Buffer.isBuffer(body) || (body instanceof Readable)) {
        return {
            body,
            headers: {
                'Content-Type': 'application/octet-stream'
            }
        };
    }
    else {
        throw new TypeError('Unsupported request body');
    }
}
//# sourceMappingURL=fetch.js.map